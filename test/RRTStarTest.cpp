#include <gtest/gtest.h>
#include <cmath>

// Class header file
#include "RRTStar.hpp"

RRTStar samplePlan;  ///< Initialize Test planner

std::vector<std::pair<double, double>>
    sampleBoundary;  ///< variable to hold boundary vertices
std::vector<std::vector<double>>
    sampleObstacles;  ///< variable to hold obstacles and their vertices

/**
 *@brief Test case to check the RRT Star planner. The test case checks whether
 the path found is correct based on the following three conditions:

         1. The last waypoint of the path should be the goal node. (i.e the goal
            node is a leaf node in the RRTree)
         2. Tracing the parent of the goal node in the tree, the path should end
            at the start node i.e root node
         3. The distance between each waypoint should be within drivable range
            of the planner

 *@param none
 *@return none
 */
TEST(RRTStarValidPathTest, testValidityOfPathGivenByTheRRTStarPlanner) {
  // Define the environment
  sampleBoundary.push_back(std::make_pair(0.0, 0.0));
  sampleBoundary.push_back(std::make_pair(100.0, 0.0));
  sampleBoundary.push_back(std::make_pair(100.0, 100.0));
  sampleBoundary.push_back(std::make_pair(0.0, 100.0));

  sampleObstacles.push_back({0.0, 80.0, 10.0, 80.0, 10.0, 90.0, 0.0, 90.0});
  sampleObstacles.push_back({0.0, 90.0, 25.0, 90.0, 25.0, 100.0, 0.0, 100.0});
  sampleObstacles.push_back({20.0, 0.0, 80.0, 0.0, 80.0, 15.0, 20.0, 15.0});
  sampleObstacles.push_back({93.0, 40.0, 100.0, 40.0, 100.0, 90.0, 93.0, 90.0});

  // Set the map for the planner
  samplePlan.setMap(sampleBoundary, sampleObstacles);

  // Set start and goal point
  std::vector<double> start = {1.0, 1.0};
  std::vector<double> goal = {50.0, 55.0};

  samplePlan.setStartAndGoal(start, goal);

  // Execute the planner
  samplePlan.runPlanner();

  // Get the planner path
  auto waypoints = samplePlan.getPlannerPath();

  // Get the tree generated by the planner
  auto tree = samplePlan.getRRTree();

  // 1. The last waypoint of the path should be the goal node. (i.e the goalnode
  // is a leaf node in the RRTree)
  std::vector<double> planGoal = {waypoints.back().first,
                                  waypoints.back().second};
  ASSERT_EQ(goal, planGoal);

  // 2. Tracing the parent of the goal node in the tree, the path should end at
  // the start node i.e root node
  auto RRTree = samplePlan.getRRTree();
  auto goalPtr = samplePlan.getGoalNodePtr();
  auto parent = goalPtr->getParent();
  std::vector<double> rootNode;
  while (parent != nullptr) {
    rootNode = parent->getState();
    parent = parent->getParent();
  }
  ASSERT_EQ(start, rootNode);

  // 3. The distance between each waypoint should be within drivable range of
  // the planner
  double driveParam = samplePlan.getPlannerParameters().second;
  for (size_t it = 0; it < waypoints.size() - 1; it++) {
    auto child = waypoints[it];
    auto parent = waypoints[it + 1];

    auto dist =
        std::hypot(parent.first - child.first, parent.second - child.second);

    ASSERT_LE(dist, driveParam + 0.0001);
  }
}

TEST(RRTStarPlannerResetTest, testRRTStarResetFunction) {
  // Define the environment
  sampleBoundary.push_back(std::make_pair(0.0, 0.0));
  sampleBoundary.push_back(std::make_pair(100.0, 0.0));
  sampleBoundary.push_back(std::make_pair(100.0, 100.0));
  sampleBoundary.push_back(std::make_pair(0.0, 100.0));

  sampleObstacles.push_back({0.0, 80.0, 10.0, 80.0, 10.0, 90.0, 0.0, 90.0});
  sampleObstacles.push_back({0.0, 90.0, 25.0, 90.0, 25.0, 100.0, 0.0, 100.0});
  sampleObstacles.push_back({20.0, 0.0, 80.0, 0.0, 80.0, 15.0, 20.0, 15.0});
  sampleObstacles.push_back({93.0, 40.0, 100.0, 40.0, 100.0, 90.0, 93.0, 90.0});

  // Set the map for the planner
  samplePlan.setMap(sampleBoundary, sampleObstacles);

  // Set start and goal point
  std::vector<double> start = {1.0, 1.0};
  std::vector<double> goal = {50.0, 51.0};

  samplePlan.setStartAndGoal(start, goal);

  // Execute the planner
  samplePlan.runPlanner();

  // Reset the planner
  samplePlan.resetPlanner();

  // Assert segmentation fault when trying to access the RRTree or the planned
  // path
  ASSERT_EXIT((samplePlan.getRRTree(), exit(0)), ::testing::ExitedWithCode(0),
              ".*");
}
